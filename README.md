What was the problem you were solving in the projects for this course?
In these projects, I worked on designing and implementing efficient data structures to manage and manipulate course information for a university advising program. The first project focused on analyzing runtime and memory usage for different data structures, while the second project involved building a binary search tree (BST) to store, sort, and retrieve course information in alphanumeric order.

How did you approach the problem? Consider why data structures are important to understand.
To approach the problem, I analyzed various data structures like arrays, linked lists, and binary search trees to determine their suitability for different operations, such as insertion, search, and traversal. For Project Two, I chose a BST due to its efficiency in maintaining sorted data and enabling fast searches. Understanding the trade-offs between different data structures helped ensure the solution was optimal for the project's requirements.

How did you overcome any roadblocks you encountered while going through the activities or project?
One challenge was implementing the BST's recursive functions for insertion and in-order traversal. Debugging and testing were essential to ensure the tree behaved as expected, especially when handling edge cases like duplicate course numbers or missing prerequisites. I resolved issues by stepping through the logic using print statements and leveraging online resources for reference.

How has your work on this project expanded your approach to designing software and developing programs?
This project reinforced the importance of selecting the right data structure based on the problem's needs. It also highlighted the value of modular design, where functions are clearly defined and reusable. I gained a deeper appreciation for the relationship between efficient algorithms and clean, maintainable code.

How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?
I have started paying closer attention to structuring my code with clarity and maintainability in mind. Using meaningful variable and function names, writing modular code, and including inline comments for complex logic have all improved my programming style. Additionally, considering scalability from the outset ensures that the code can handle future requirements or modifications.
